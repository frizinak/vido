#! /bin/bash
set -e

usage () {
    echo "Usage: $(basename "$0") [-crl] [-t seconds] <timeline-file>"
    echo "    -c: also remove old proxy files"
    echo "    -r: use dnxhd (lossless) for the final videos"
    echo "    -l: use hevc  (lossy)    for the proxy videos"
    echo "    -t: cut all clips to the given duration in seconds."
    echo "        effectively ignoring the end timestamp in the timeline-file"
    # echo "    -n: shows you how to normalize a file"
}

################################################################################

codec_v_dnxhd_444=(  -c:v dnxhd                                   -profile:v dnxhr_444 -pix_fmt yuv444p10le)
codec_v_dnxhd_hqx=(  -c:v dnxhd                                   -profile:v dnxhr_hqx -pix_fmt yuv422p    )
codec_v_dnxhd_hq=(   -c:v dnxhd                                   -profile:v dnxhr_hq  -pix_fmt yuv422p    )
codec_v_hevc_nvenc=( -c:v hevc_nvenc -b_ref_mode 0 -rc vbr -cq 16 -preset:v  slow      -pix_fmt yuv420p    )
codec_v_h264_nvenc=( -c:v h264_nvenc               -rc vbr -cq 12 -preset:v  slow      -pix_fmt yuv420p    )
codec_v_hevc=(       -c:v hevc                     -rc vbr -cq 16 -preset:v  slow                          )
codec_v_h264=(       -c:v h264                     -rc vbr -cq 12 -preset:v  slow                          )
codec_a_pcm=(        -c:a pcm_s16le                                                                        )
codec_a_aac=(        -c:a aac                                                                              )

# directory to store proxy files in.
PROXY_DIR="./.vido-parts"

# path to an haldclut image that is applied to each proxy file
CLUT=

# ffmpeg vidstabtransform options, no stabilization is performed if empty
STAB=

# The next proxy file will also get a hard link to ${PROXY_DIR}/part-${LABEL}.mov
LABEL=

# Applied to each proxy file before the proxy specific filters are applied
FILTER_BEFORE=

# Applied to each proxy file after the proxy specific filters are applied
FILTER_AFTER=

# Base ffmpeg command
FFMPEG=(ffmpeg -hide_banner -nostdin -loglevel error -hwaccel:v auto -filter_complex_threads 6 -filter_threads 6)

# Sections a set of proxies into a single clip.
SECTION=

# If set to 1 the proxies after it are not created. (vido -c will not delete any disabled proxies)
DISABLED=

# The ffmpeg codec related params when generating the proxy files.
PROXY_CODEC_PARAMS=("${codec_v_dnxhd_444[@]}" "${codec_a_pcm[@]}")

# The ffmpeg codec related params for the final clip command.
OUTPUT_CODEC_PARAMS=("${codec_v_hevc_nvenc[@]}" "${codec_a_aac[@]}")

# Maximum amount of concurrent ffmpeg instances.
CONCURRENCY=${CONCURRENCY:-4}

################################################################################

debug_seconds=0
clean=0
while getopts ':crlt:h' o; do
    case "$o" in
        c)
            clean=1
            ;;
        r)
            OUTPUT_CODEC_PARAMS=("${codec_v_dnxhd_444[@]}" "${codec_a_pcm[@]}")
            ;;
        l)
            PROXY_DIR="./.vido-parts-lossy"
            PROXY_CODEC_PARAMS=("${codec_v_hevc_nvenc[@]}" "${codec_a_aac[@]}")
            ;;
        t)
            debug_seconds="$OPTARG"
            ;;
        # n)
        #     fn="$OPTARG"
        #     base="$(basename "$OPTARG" | rev | cut -d. -f2- | rev)"
        #     echo "${FFMPEG[*]} -i $fn -f lavfi -i anullsrc=cl=mono -f lavfi -i nullsrc=size=256x120 -c:a pcm_s16le -pix_fmt yuv420p -shortest -c:v hevc_nvenc -b_ref_mode 0 -cq 12 -preset:v slow  proxy-$base.mov";
        #     exit 0
        #     ;;
        h)
            usage;
            exit 0
            ;;
        ?)
            usage
            exit 1
            ;;
    esac
done

if [ "$debug_seconds" == "0" ]; then
    debug_seconds=
fi

shift "$((OPTIND -1))"

################################################################################

input=${1:-Timeline}
rm "$PROXY_DIR/"*".tmp" 2>/dev/null || :
parts=()
nw_files=()
part_prefix="part-"
ex_files=("$PROXY_DIR/$part_prefix"*)

sections=()
sections_enabled=()
section_ix=()

processes=0
lbl=0
pids=()
pids_info=()

last_section=-1

linenr=0

noaudio=
novideo=
streams=()

timerange_re='[0-9_:\.]+-[0-9_:\.]+'
trimspace() {
    sed -E 's/(^\s*)|(\s*$)//g'
}

file_pad="$(grep -Eo "^.*${timerange_re}" "$input" | rev | cut -d' ' -f2- | rev | trimspace | awk '{ if (length > max) max = length } END { print max }')"

while read -r line; do
    linenr=$(( linenr + 1 ))
    line="$(echo "$line" | sed 's/#.*//')"
    if [ "$(echo "$line" | sed 's/ +//g')" = "" ];then
        continue
    fi

    if echo "$line" | grep -E '^\s*[_a-zA-Z0-9]+=' &>/dev/null; then
        printf "\033[48;5;238m\033[38;5;255m      %-$(( file_pad+51 ))s [VAR] \033[0m\n" "$(echo "$line" | cut -d= -f1)" >&2
        eval "$line"
        continue
    fi

    lbl=$(( lbl + 1 ))
    mkdir "$PROXY_DIR" 2>/dev/null || :
    part="$(echo "$line" | grep -Eo "^.*${timerange_re}" || :)"
    if [ "$part" = "" ]; then
        printf "invalid line %d: '%s'\n" $linenr "$line" >&2
        exit 1
    fi

    usrf="$(echo "${line:${#part}}" | trimspace)"
    strm="$(echo "${part}" | grep -Eo '^[ va]+ ' | trimspace || :)"
    file="$(echo "${part:${#strm}}" | rev | cut -d' ' -f2- | rev | trimspace)"
    time="$(echo "${part:${#strm}}" | rev | cut -d ' ' -f1 | rev | sed 's/_/0/g')"
    from="$(echo "$time" | cut -d- -f1)"
    till="$(echo "$time" | cut -d- -f2)"
    if [ "$(echo "$till" | sed 's/[0_:\.]\+//g')" = "" ]; then
        till=
    fi
    if [ "$debug_seconds" != "" ]; then
        till=
    fi

    novideo=0
    noaudio=0
    if [ ${#strm} -eq 0 ]; then
        strm='va'
    fi
    if ! echo "$strm" | grep 'v' &>/dev/null; then
        novideo=1
    fi
    if ! echo "$strm" | grep 'a' &>/dev/null; then
        noaudio=1
    fi

    streams+=("$strm")

    prefix=(-ss "$from")
    if [ "$till" != "" ]; then
        prefix+=(-to "$till")
    fi
    if [ "$debug_seconds" != "" ]; then
        prefix+=(-t "$debug_seconds")
    fi
    prefix+=(-i "$file")

    enabled=1
    if [ "$DISABLED" == "1" ]; then
        enabled=0
    fi
    if [ "$last_section" != "$SECTION" ]; then
        sections+=("$SECTION")
        section_ix+=($(( lbl - 1 )))
        sections_enabled+=($enabled)
        last_section="$SECTION"
    fi

    outfile_prefix="$(printf '%s/%s' "$PROXY_DIR" "$part_prefix")"

    hash_stab="$(echo "${prefix[*]}" | sha1sum - | cut -d' ' -f1)"
    outfile_stab="$(printf '%s%s.stab' "$outfile_prefix" "$hash_stab")"

    filters=()
    if [ "$novideo" != "1" ]; then
        if [ "$FILTER_BEFORE" != "" ]; then
            filters+=("[main]${FILTER_BEFORE}[main]")
        fi
        if [ "$usrf" != "" ]; then
            filters+=("[main]${usrf}[main]")
        fi
        if [ "$STAB" != "" ]; then
            filters+=("[main]vidstabtransform=$STAB:input=${outfile_stab}" "unsharp=5:5:0.8:3:3:0.4[main]")
        fi
        if [ "$CLUT" != "" ]; then
            filters+=("[main][1]haldclut=interp=trilinear[main]")
        fi
        if [ "$FILTER_AFTER" != "" ]; then
            filters+=("[main]${FILTER_AFTER}[main]")
        fi
        if [ ${#filters[@]} = 0 ]; then
            filters=("[main]null[main]")
        fi
        filters[0]="$(echo "${filters[0]}" | sed 's/\[main\]/[0]/')"
    fi

    suffix=("${PROXY_CODEC_PARAMS[@]}")
    if [ "$novideo" != "1" ]; then
        suffix+=(-map '[main]')
    fi
    if [ "$noaudio" != "1" ]; then
        suffix+=(-map '0:a')
    fi

    filter_str="$(IFS=,; echo "${filters[*]}")"
    filter_arg=()
    if [ "$filter_str" != "" ]; then
        filter_arg=(-filter_complex "$filter_str")
    fi

    hash_main="$(echo "${prefix[*]} $CLUT $filter_str ${suffix[*]}" | sha1sum - | cut -d' ' -f1)"
    outfile_main="$(printf '%s%s.mov'  "$outfile_prefix" "$hash_main")"

    while [[ processes -ge CONCURRENCY ]]; do
        # exit code is irrelevant (see `help wait`)
        wait -n || :
        processes=$((processes-1))
    done

    outfile_label=
    if [ "$LABEL" != "" ]; then
        ext="$(echo "$outfile_main" | rev | cut -d. -f1 | rev)"
        outfile_label="${PROXY_DIR}/${part_prefix}${LABEL}.${ext}"
    fi
    LABEL=
    processes=$((processes+1))
    {
        if [ $enabled -ne 1 ]; then
            exit
        fi
        tmp_stab="$outfile_stab.tmp";
        tmp_main="$outfile_main.tmp";
        lock_stab="$outfile_stab.lock"
        lock_main="$outfile_main.lock"

        exec 9<>"$lock_stab"
        flock -x 9

        err=0
        if [ "$novideo" != "1" ] && [ "$STAB" != "" ] && [ ! -f "$outfile_stab" ]; then
            printf "\033[48;5;227m\033[38;5;232m %03d) \033[1m%-${file_pad}s \033[22m%-50s [STB] \033[0m\n" $lbl "$file" "${outfile_stab:${#PROXY_DIR}+1}" >&2
            "${FFMPEG[@]}" -n "${prefix[@]}" \
                -an \
                -vf "vidstabdetect=result=$tmp_stab" \
                -f null \
                - <&- && mv "$tmp_stab" "$outfile_stab" || err=$?
        fi

        rm "$lock_stab" || :
        exec 9<&-

        if [ $err -ne 0 ]; then
            exit $err
        fi

        if [ "$CLUT" != "" ]; then
            prefix+=(-i "$CLUT")
        fi

        exec 9<>"$lock_main"
        flock -x 9

        if [ ! -f "$outfile_main" ]; then
            printf "\033[48;5;227m\033[38;5;232m %03d) \033[1m%-${file_pad}s \033[22m%-50s [CNV] \033[0m\n" $lbl "$file" "${outfile_main:${#PROXY_DIR}+1}" >&2
            "${FFMPEG[@]}" -n "${prefix[@]}" \
                "${filter_arg[@]}" \
                "${suffix[@]}" \
                -f mov \
                "$tmp_main" <&- && mv "$tmp_main" "$outfile_main" || err=$?
        fi

        rm "$lock_main" || :
        exec 9<&-

        if [ "$outfile_label" != "" ]; then
            ln -f "$outfile_main" "$outfile_label"
        fi

        if [ $err -ne 0 ]; then
            exit $err
        fi

        printf "\033[48;5;155m\033[38;5;232m %03d) \033[1m%-${file_pad}s \033[22m%-50s [RDY] \033[0m\n" $lbl "$file" "${outfile_main:${#PROXY_DIR}+1}" >&2
    } &
    pids+=("$!")
    pids_info+=("$(printf "\033[48;5;203m\033[38;5;232m %03d) \033[1m%-${file_pad}s \033[22m%-50s [ERR] \033[0m" $lbl "$file" "")")

    parts+=("$outfile_main")
    nw_files+=("$outfile_main" "$outfile_stab")
    if [ "$outfile_label" != "" ]; then
        nw_files+=("$outfile_label")
    fi
done < "$input"

# we need separate waits to test every background jobs' exit code.
errix=-1
for ix in "${!pids[@]}"; do
    if ! wait "${pids[$ix]}"; then
        errix=$ix
    fi
done

if [ $errix -ge 0 ]; then
    echo -e "${pids_info[$errix]}" >&2
    exit 1
fi

if [ $clean -eq 1 ]; then
    for ex in "${ex_files[@]}"; do
        if [ ! -f "$ex" ]; then
            continue
        fi
        found=0
        for n in "${nw_files[@]}"; do
            if [ "$n" == "$ex" ]; then
                found=1
                break
            fi
        done

        if [ $found -eq 0 ]; then
            echo "removing '$ex'" >&2
            rm "$ex"
        fi
    done
fi

################################################################################
echo "#! /bin/bash"

for ix in "${!sections[@]}"; do
    if [ ${sections_enabled[$ix]} -eq 0 ]; then
        continue
    fi

    section_name="${sections[$ix]:-main-$(( ix + 1 ))}"
    offset=${section_ix[$ix]}
    end=${section_ix[$ix+1]:-${#parts}}
    echo
    echo "# Section $section_name"

    cmd=(ffmpeg -loglevel error -stats -hwaccel:v auto -filter_complex_threads 6 -filter_threads 6)
    filter=""
    lbl=0
    suboffset=$offset
    hasaudio=
    hasvideo=
    stream_count=0
    for file in "${parts[@]:$offset:$end}"; do
        strm="${streams[$suboffset]}"

        cmd+=(-i "$file")
        if echo "$strm" | grep 'v' &>/dev/null; then
            stream_count=$(( stream_count + 1 ))
            hasvideo=1
            filter="${filter}[$lbl:v]"
        fi
        if echo "$strm" | grep 'a' &>/dev/null; then
            stream_count=$(( stream_count + 1 ))
            hasaudio=1
            filter="${filter}[$lbl:a]"
        fi
        lbl=$(( lbl + 1 ))
        suboffset=$(( suboffset + 1 ))
    done
    filter="${filter}concat=n=$(( stream_count / 2 )):v=${hasvideo}:a=${hasaudio}"
    if [ $hasvideo -eq 1 ]; then
        filter="${filter}[v]"
    fi
    if [ $hasaudio -eq 1 ]; then
        filter="${filter}[a]"
    fi

    cmd+=(-filter_complex "$filter")
    if [ $hasvideo -eq 1 ]; then
        cmd+=(-map '[v]')
    fi
    if [ $hasaudio -eq 1 ]; then
        cmd+=(-map '[a]')
    fi
    cmd+=("${OUTPUT_CODEC_PARAMS[@]}")

    for p in "${cmd[@]}"; do
        echo -n "$p "
        if [ ${#p} -ne 0 ] && [ ${p:0:1} != "-" ]; then
            echo "\\"
            echo -n "    "
        fi
    done
    echo "output-$section_name.mov"
done
